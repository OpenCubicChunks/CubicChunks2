package io.github.opencubicchunks.cubicchunks.mixin.core.common;

import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import io.github.opencubicchunks.cubicchunks.mixin.transform.typetransformer.transformer.CCSynthetic;
import io.github.opencubicchunks.cubicchunks.mixin.transform.typetransformer.transformer.TypeTransformer;
import io.github.opencubicchunks.cubicchunks.mixin.transform.util.ASMUtil;
import net.minecraft.CrashReport;
import net.minecraft.CrashReportCategory;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
import org.spongepowered.asm.mixin.injection.callback.LocalCapture;

//This will append an extra message to the crash report warning the user that it may be caused by 3-int transforms
@Mixin(CrashReport.class)
public class MixinCrashReport {
    @Shadow private StackTraceElement[] uncategorizedStackTrace;

    @Shadow @Final private List<CrashReportCategory> details;

    @Inject(
        method = "getFriendlyReport",
        at = @At(
            value = "INVOKE",
            target = "Ljava/lang/StringBuilder;append(Ljava/lang/String;)Ljava/lang/StringBuilder;",
            ordinal = 3,
            shift = At.Shift.AFTER
        ),
        locals = LocalCapture.CAPTURE_FAILHARD
    )
    private void appendWarning(CallbackInfoReturnable<String> cir, StringBuilder sb) {
        Set<Method> methods = new HashSet<>();

        if (this.uncategorizedStackTrace != null) {
            findSynthetic(methods, this.uncategorizedStackTrace);
        }

        for (CrashReportCategory detail : this.details) {
            if (detail.getStacktrace() != null) {
                findSynthetic(methods, detail.getStacktrace());
            }
        }

        if (!methods.isEmpty()) {
            sb.append("WARNING: The following stacktrace(s) contain methods generated by cubic chunks. The methods of interest are the following:\n");

            int i = 1;
            for (Method method : methods) {
                CCSynthetic synthetic = method.getAnnotation(CCSynthetic.class);
                String original = synthetic.original();
                int idx = original.indexOf('(');
                String name = original.substring(0, idx);
                String desc = original.substring(idx);

                sb.append("  - Method #").append(i).append(":\n");
                sb.append("    - Class: ").append(method.getDeclaringClass().getName()).append("\n");
                sb.append("    - Transformed Method: ").append(method.getName()).append(" ").append(ASMUtil.getDescriptor(method)).append("\n");
                sb.append("    - Original Method: ").append(name).append(" ").append(desc).append("\n");
                i++;
            }
        }
    }

    private void findSynthetic(Set<Method> set, StackTraceElement[] stackTrace) {
        for (StackTraceElement element : stackTrace) {
            Method method = getMethodIfSynthetic(element);

            if (method != null) {
                set.add(method);
            }
        }
    }

    private @Nullable Method getMethodIfSynthetic(StackTraceElement element) {
        try {
            Class<?> clazz = Class.forName(element.getClassName());
            return TypeTransformer.getSyntheticMethod(clazz, element.getMethodName(), element.getLineNumber());
        } catch (ClassNotFoundException e) {
            //Do nothing
        }

        return null;
    }
}
